<!DOCTYPE html>
<meta charset="utf-8">
<style>
</style>
<svg ></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
var svg = d3.select("svg").attr("preserveAspectRatio", "xMinYMin meet")
.attr("viewBox", "0 0 960 500")
let width = 960,
height = 500;
resolution = 10;
//used to capture drag position    
var start_x, start_y;     

//create some circles at random points on the screen 
//create 50 circles of radius 20
//specify centre points randomly through the map function 

//stylish black rectangle for sexy looks 
var rect = svg.append("g")
  .attr("class", "rect")
  .append("rect")
  .attr("width", width)
  .attr("height", height)
  .style("fill", "rgb(238,242,249)");

var boxG = svg.append("g")

var numBoxes = 30;
var arr = d3.range(0,numBoxes+5);
var boxSize = width/numBoxes;

var boxEnter = boxG.selectAll("line").data(arr).enter();
  boxEnter.append("line").attr("x1", function (d){return d * boxSize})
    .attr("x2", function (d){return d*boxSize;})
    .attr("y1", 0).attr("y2", height)
    .style("stroke", "rgb(208,202,209)");
        
  boxEnter.append("line")
    .attr("x1", 0)
    .attr("x2", width)
    .attr("y1", function (d){return d* boxSize})
    .attr("y2", function (d){return d* boxSize}).style("stroke", "rgb(208,202,209)");

var radius = 10;

var circle_data = d3.range(10).map(function() {
    return{
        x : Math.round(Math.random() * width,  boxSize),
        y : Math.round(Math.random() * height, boxSize)
    }; 
}); 


var circle_d = d3.range(2).map(function() {
    return{
        x : Math.round(width,  boxSize),
        y : Math.round(height, boxSize)
    }; 
}); 
    
//funky yellow circles   
var circles = d3.select("svg")
  .append("g")
	.attr("class", "circles")
	.selectAll("circle")
    .data(circle_data)
    .enter()
    .append("circle")
    .attr("cx", function(d) {return(d.x)})
    .attr("cy", function(d) {return(d.y)})
    .attr("r", radius)
    .attr("fill", "lightsteelblue");       

/* 
 * DRAG BEHAVIOUR         
 */   

//create drag handler with d3.drag()
var drag_handler = d3.drag()
    .on("drag", drag_drag);

function drag_drag(d) {
    //Get the current scale of the circle 
    //case where we haven't scaled the circle yet
    var start_x = d3.event.x;
    var start_y = d3.event.y;
    let gridX = round(Math.max(radius, Math.min(width - radius, start_x)), boxSize);
    let gridY = round(Math.max(radius, Math.min(height - radius, start_y)), boxSize);
    console.log(gridX, gridY)
    d3.select(this).attr('cx', d.x = gridX).attr('cy', d.y = gridY);
      // d3.select(this)
      //   .attr("cx", d.x = start_x + ((d3.event.x - start_x) / current_scale) )
      //   .attr("cy", d.y = start_y + ((d3.event.y - start_y) / current_scale));
}

function round(p, n) {
  return p % n < n / 2 ? p - (p % n) : p + n - (p % n);
}
             
//apply the drag_handler to our circles 
drag_handler(circles);    
 
/* 
 * ZOOM BEHAVIOUR         
 */       
      
//create zoom handler 
var zoom_handler = d3.zoom()
    .on("zoom", zoom_actions);

    
//specify what to do when zoom event listener is triggered 
function zoom_actions(){
  
  var transform = d3.event.transform;
  console.log()
  //   var newViewBox = [
  //     -transform.x / transform.k,
  //     -transform.y / transform.k,
  //     width / transform.k,
  //     height / transform.k
  //   ].join(" ");
  //   console.log(newViewBox)
    // svg.attr('viewBox', newViewBox);
  circles.attr("transform", d3.event.transform);
}

//add zoom behaviour to the svg element backing our graph.  
//same thing as svg.call(zoom_handler); 
zoom_handler(svg);

</script>
